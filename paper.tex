\documentclass{vldb}

%%% Packages
\usepackage{graphicx}
\usepackage{balance}
\usepackage{tikz}
\usepackage{standalone}
\usepackage{subfigure}

%%% TikZ libraries
\usetikzlibrary{backgrounds, positioning, decorations.pathreplacing, calc, fit}
\usetikzlibrary{shapes}

%%% Macros
\newcommand{\tbr}{\textbf{[TO BE REVISED]}}
\newcommand{\tbd}{\textbf{[TO BE DONE]}}

\begin{document}

% Title
\title{A Survey on Ordered Binary Decision Diagrams}

% Author(s)
\numberofauthors{1}

\author{
\alignauthor
	Daniel Kocher\\
    \affaddr{University of Salzburg}\\
    \email{Daniel.Kocher@stud.sbg.ac.at}
}

\maketitle

\begin{abstract}
This paper serves as a survey on \textit{ordered binary Decision diagrams}
(\textit{OBDDs}). It provides an overview of the representation of OBDDs, the
operations which can be applied efficiently, some aspects when implementing them
as well as their limitations and how to probably overcome them by using
alternative representations. No new results or insights are provided. \tbr
\end{abstract}

\section{Introduction}
\label{sec:introduction}

In computer-aided design (CAD) as well as other domains like artificial
intelligence or combinatorics, many problems can be formulated as Boolean
functions. These Boolean functions then can be represented symbolically using the
\textit{Binary Decision Diagrams} (\textit{BDDs}) introduced by Lee\cite{LEE59}
and Akers\cite{AKERS78} in 1959 and 1978, respectively.

In 1986 Bryant\cite{BRYANT86} published a paper of high impact, describing a
\textit{reduced} and \textit{ordered} class of BDDs, so-called \textit{ROBDDs}
(\textit{Reduced Ordered} BDDs) but in literature mostly referred to as
\textit{OBDDs}. OBDDs represent Boolean functions in a \textit{canonical}
form. This results in a compact form and very efficient tests for some properties,
e.g. satisfiability or equivalence\cite{BRYANT86}.

Bryant also introduced and experimentally evaluated efficient implementation
techniques for OBDDs in collaboration with Brace and
Rudell~\cite{BRACE90, BRYANT92}.

Already in the inital paper describing OBDDs, the importance of the variable
ordering was highlighted. Only if the variable ordering is chosen properly, it
will result in a small graph (OBDD) and, in turn, in more efficient testing.

Nonetheless representing Boolean functions using OBDDs has some drawbacks. Classes
of Boolean functions exist for which the size of the graph grows exponentially
independent of the variable ordering, e.g. integer
multiplication~\cite{BRYANT86, BRYANT91, WOELFEL01}.

These limitations of OBDDs motivated researchers to introduce heuristics and
other techniques like \textit{dynamic variable ordering}~\cite{RUDELL93} to solve
the problem of variable ordering~\cite{BOLLIG96}. Furthermore, alternative
representations which e.g. relax the ordering~\cite{BRYANT95} or change the
interpretation of nodes~\cite{BRYANT95, ANDERSEN97} were developed. Such
representations may be beneficial for some classes of Boolean functions but mostly
suffer from losing the canonical form and hence the desirable properties OBDDs
are famous for.

This paper serves as survey on symbolic Boolean function manipulation using OBDDs.
The following section describes the representation of Boolean functions through
BDDs as well as OBDDs. It also highlights the advantages and disadvantages of the
OBDD representation. The third section describes operations which can be applied
to OBDDs efficiently. No source code is provided but those can be looked up in
the corresponding papers easily (references are provided for each algorithm).
Section~\ref{sec:implementational-aspects} describes aspects one has to take into
account when implementing an OBDD package, such as what data structures to use
or how to deal with the problem of variable ordering. Limitations of the OBDD
representation are described in the subsequent section. The last section
discusses alternative representations to possibly overcome the limitations of
the OBDD representation. \tbr

\section{Representation Basics}
\label{sec:representation-basics}

\textit{Binary decision diagrams} (\textit{BDDs}) have been well studied since
Lee~\cite{LEE59} and especially Akers~\cite{AKERS78} introduced them. BDDs
represent a Boolean function $f$ as an acyclic, directed graph (DAG). The function
arguments may be omitted in some cases to keep the formulas simple, i.e. $f$
denotes $f(x_1, \ldots, x_2)$. Nodes represent variables and have one incoming
and two outgoing edges, each of which denotes the variable evaluates to 0 (left)
or 1 (right), respectively. Whenever the result of $f$ is fixed, an edge points
to one of the constant functions \textbf{0} or \textbf{1}. To evaluate $f$ for a
given variable assignment, one just follows the path for the respective variable
values. As soon as the path ends up in a constant, i.e. \textbf{0} or \textbf{1},
this is the result of the corresponding variable assignment. Akers~\cite{AKERS78}
already provided some techniques to simplify the BDD representation such as
combining equivalent nodes.

Figure~\ref{subfig:bdd} shows an example of a BDD representing the Boolean function
$f=(A \land B) \lor (B \land C)$. To simplify the graphs, the diagram style of
Bryant~\cite{BRYANT92} is reused, i.e. edge labels are skipped. Instead dashed
and solid lines are used to represent the value of the decision variable to be 0
and 1, respectively. This diagram style is used throughout this paper.

\begin{figure}[ht]
    \centering
    \subfigure[BDD]{
        \includestandalone[height = 3cm]{figs/bdd}
        \label{subfig:bdd}
    }
    \hskip1cm
    \subfigure[OBDD]{
        \includestandalone[height = 3cm]{figs/obdd}
        \label{subfig:obdd}
    }
    \caption{BDD and OBDD of $f=(A \land B) \lor (B \land C)$.}
    \label{fig:bdd-and-obdd}
\end{figure}

However, Bryant~\cite{BRYANT86} introduced some restrictions concerning the
ordering of the so-called \textit{decision variables} represented by the nodes
of the BDD. Furthermore, Bryant\cite{BRYANT86} was able to derive a reduced
representation of BDDs providing the DAG in a canonical form: the
\textit{Reduced Ordered Binary Decision Diagram} (\textit{ROBDD}; mostly referred
to as \textit{OBDD}, even by Bryant himself). In this paper, the terms ROBDD and
OBDD are used synonymously.

Figure~\ref{subfig:obdd} shows one possible ROBDD representation of
$f$. The following section covers the details of how
to derive the OBDD representation from a BDD. \tbr

\subsection{From BDDs to OBDDs}
\label{subsec:from-bdds-to-obdds}

As the name suggests, \textit{Reduced} Ordered Binary Decision Diagrams are a 
minimized representation of BDDs. Furthermore, the decision variables are ordered
consistently. More formally, for any node $n$ and their respective children $m_1$
and $m_2$, a total ordering is imposed, i.e. $var(n) < var(m_1)$ and
$var(n) < var(m_2)$, respectively, where $var(x)$ denotes the label of node
$x$~\cite{BRYANT86, BRYANT92}.

This \textit{variable ordering} affects the efficiency of the symbolic
manipulation because different variable orderings, in general, produce different
OBDDs. In the worst case, this will result in exponential complexity for bad
orderings. Nevertheless, as will be described in Section~\ref{sec:limitations},
there exist classes of functions for which the OBDD complexity is exponential
regardless of which variable ordering is chosen.

Before discussing the reduction procedure, some definitions are necessary. Here
the original definitions of Bryant~\cite{BRYANT86, BRYANT91} are reused.

A Boolean function can be represented as an OBDD, i.e. a rooted, directed,
acyclic graph (DAG) with a set of nodes $V$ as well as a set of edges $E$. 

There exist \textit{nonterminal} and \textit{terminal} nodes. Each
\textit{nonterminal} node $n$ has its own label $var(n)$ as well as two edges,
connecting it to its left $lo(n)\in V$ and right child $hi(n)\in V$, respectively. 
Each \textit{terminal} node $t$ has a unique value $value(t)$, i.e. $value(t)$
is a constant function (for Boolean functions \textbf{0} or \textbf{1}). Hence,
for each constant function only a single terminal node exists.

The following property has to hold for any nonterminal node $n$ in order to
satisfy the ordering requirement of an OBDD:
$var(n) < var(lo(n)) \land var(n) < var(hi(n))$.
In other words, for any path starting at the root of an OBDD, if a path is
followed until a terminal node is reached, the nonterminal nodes are traversed
strictly in the variable ordering.

\paragraph*{Reduction procedure}
\mbox{} % workaround to get line break after paragraph

Bryant~\cite{BRYANT86, BRYANT92} described three transformation rules to reduce
a graph such that it still represents the same function as before.

For each constant function, there exists only a single terminal node representing
it, e.g. for Boolean functions, only two terminal nodes exist, representing
\textbf{0} and \textbf{1}, respectively. Hence, when transforming a given BDD,
eliminate all but one terminal node for each constant function and redirect all
edges accordingly, i.e. to the one remaining node for each constant function.

There may be duplicate nonterminal nodes present in a given BDD. Formally, a node
$d$ is a duplicate if $var(d) = var(n) \land lo(d) = lo(n) \land hi(d) = hi(n)$
holds for any other node $n$. If this is the case, $d$ can be eliminated and all
edges are redirected to $n$.

The third and last transformation rule deals with completely redundant nonterminal
nodes. Intuitively, this rule should be straightforward: any node having the same
child on all outgoing edges is redundant because the actual value of the variable
does not change the result of the function. More formally, a nonterminal node $n$
is redundant if and only if $lo(n) = hi(n)$. Then, all incoming edges of $n$ can
be redirected to $lo(n)$ and $n$ can be deleted afterwards.

\begin{figure}[ht]
    \centering
    \subfigure[]{
        \includestandalone[height = 3cm]{figs/redundant-nonterminals-before}
        \label{subfig:redundant-nonterminals-before}
    }
    \hskip1cm
    \subfigure[]{
        \includestandalone[height = 3cm]{figs/redundant-nonterminals-after}
        \label{subfig:redundant-nonterminals-after}
    }
    \caption{Eliminating redundant nonterminal nodes.}
    \label{fig:redundant-nonterminals}
\end{figure}

Figure~\ref{fig:bdd-and-obdd} shows the result, \ref{subfig:obdd}, of applying
the first two transformation rules to the BDD shown in \ref{subfig:bdd}.
The third rule is shown in Figure~\ref{fig:redundant-nonterminals}:
\ref{subfig:redundant-nonterminals-before} shows a BDD with redundant
nonterminal nodes (both B's, in essence) and
\ref{subfig:redundant-nonterminals-after} shows the equivalent OBDD without
redundant nonterminals.

Bryant already formally described an algorithm to transform an arbitrary graph
into a reduced one~\cite[p. 683]{BRYANT86}. 

OBDDs have one big advantage over other representations: their representation is
\textit{canonical}. As a consequence, important tests can be performed on an OBDD
in constant time, i.e. satisfiability and tautology tests. Moreover, OBDDs enable
other tests, such as variable independence and functional equivalence tests, to
be performed efficiently. \tbr

\section{Operations}
\label{sec:operations}

Bryant's~\cite{BRYANT86, BRYANT92} main focus was to define algorithms performing
symbolic operations on graphs representing Boolean functions. The most basic
operation is \textit{Apply} which applys a given operation $op$, e.g. \texttt{AND},
to two given functions $f_1$ and $f_2$, and returns the result of $f_1\;op\;f_2$.
Another operation is \textit{Restrict}, restricting a given variable $x$ to a
given (constant) value $c$, denoted $f|_{x\leftarrow c}$. Furthermore, the
operations \textit{Compose} and \textit{Satisfy} can be defined as graph
algorithms.

The following paragraphs summarize those operations and their properties briefly.
Implementation details are covered in Section~\ref{sec:implementational-aspects}.

\paragraph*{Restrict}
\mbox{} % workaround to get line break after paragraph

Although \textit{Apply} is the core operation, the \textit{Restrict} operation is
discussed first, mainly because it is used within \textit{Apply}. Besides,
\textit{Restrict} is straightforward and easy to understand.

A variable $x$, argument of a function $f$, can be restricted to a given value
$c$, denoted by $f|_{x\leftarrow c}$, as follows.

Starting from the root $n$ of the OBDD representation of $f$ and traversing the
OBDD depth-first, every node is checked for $var(n) = x$. This is done recursively
on the given graph, generating the resultant graph This node represents
the variable to be restricted. Now, there are two cases for $c$ to distinguish:
\begin{enumerate}
    \item{$c=0$: The incoming edge of $n$ is redirected to $lo(n)$.}
    \item{$c=1$: The incoming edge of $n$ is redirected to $hi(n)$.}
\end{enumerate}

By applying the three transformation rules of the reduction procedure in each
step, \textit{Restrict} generates a reduced graph immediately~\cite{BRYANT92}.

This procedure has linear time complexity in the number of nodes, i.e. $O(|V|)$,
assuming an efficient implementation (see
Section~\ref{sec:implementational-aspects} for details)~\cite{BRYANT92}. 
\tbr

\paragraph*{Apply}
\mbox{} % workaround to get line break after paragraph

Applies an operation $op$ to two given functions $f_1$ and $f_2$ and returns the
resulting function $f_1\;op\;f_2$. This is the most intuitive function one would
expect when dealing with Boolean functions and it has some interesting properties
too, i.e. the complement of $f_1$ can be computed by setting $f_2$ to \textbf{1}
and $op$ to $\oplus$ (\texttt{XOR}). Moreover, the already mentioned functional
equivalence can be tested by applying $\overline{\oplus}$ (\texttt{XNOR}) to
$f_1$ and $f_2$ for all relevant cases. Therefore, Bryant~\cite{BRYANT92} defined
a function $d(x_1, \ldots, x_n)$ for \textit{Don't cares}:

$d(x_1, \ldots, x_n)=
\begin{cases}
    1, & \text{if values are not relevant} \\
    0, & otherwise
\end{cases}
$

\noindent
Using this function, one check if $f_1$ and $f_2$ are functionally equivalent by
computing $(f_1\overline{\oplus}f_2)\lor d$. If the result is \textbf{1}, $f_1$
and $f_2$ are functionally equivalent.

\textit{Apply} traverses the given graph depth-first, creating the resultant OBDD
step by step. Starting from the roots $n_1$ and $n_2$, new nodes are created for
each branching point of the graphs of $f_1$ and $f_2$, respectively.

\textit{Shannon's expansion} forms the basis of the recursive
algorithm~\cite{BRYANT86}:
\begin{center}
$
f_1\;op\;f_2 =
\overline{x} \land \left(f_1|_{x\leftarrow 0}\;op\;f_2|_{x\leftarrow 0}\right)
\lor x \land \left(f_1|_{x\leftarrow 1}\;op\;f_2|_{x\leftarrow 1}\right)
$
\end{center}

\noindent
The recursive procedure then has three different cases. Note that a node is only
created if no equivalent node is already present in the resultant graph.
\begin{enumerate}
    \item{
        If $n_1$ and $n_2$ are both terminal nodes, then a terminal node
        representing the value $value(n_1)\;op\;value(n_2)$ is added to the
        resultant graph and the recursion terminates.
    }
    \item{
        If either $n_1$ or $n_2$ is a nonterminal node, then:
        \begin{enumerate}
            \item{
                If $var(n_1) = var(n_2)$, a node having $var(n_1)$ is created and
                the procedure is applied recursively on $(lo(n_1), lo(n_2))$ and
                $(hi(n_1), hi(n_2))$.
            }
            \item{
                If $var(n_1)$ is a nonterminal and $n_2$ is eiter a terminal node
                or $var(n_1) < var(n_2)$, a node having $var(n_1)$ is created and
                the procedure is applied recursively on $(lo(n_1), n_2)$ and
                $(hi(n_1), n_2)$.
            }
        \end{enumerate}
    }
\end{enumerate}

To get a reduced graph immediately, the three transformation rules are utilized
again for each step~\cite{BRYANT92}.

There are some refinements when it comes to implementation. Those are covered in
Section~\ref{sec:implementational-aspects} as well as the original paper of
Bryant~\cite{BRYANT86, BRYANT92}.  However, assuming an efficient implementation,
the time complexity can be bound to
$O\left(|V_{f_1}| \cdot |V_{f_2}|\right)$~\cite{BRYANT86, BRYANT92}.

The full pseudocode defined by Bryant can be found in~\cite[p. 685]{BRYANT86}. \tbr

\paragraph*{Compose}
\mbox{} % workaround to get line break after paragraph

This operation is merely based upon calls to \textit{Apply} and \textit{Restrict}.
Utilizing \textit{Shannon's expansion}, Bryant~\cite{BRYANT86} formulated the
composition of two functions $f_1$ and $f_2$ as
\begin{center}
$
f_1|_{x=f_2}=
f_2 \land f_1|_{x_i=1} \lor \overline{f_2} \land f_1|_{x_i=0}
$
\end{center}

However, this would result in an algorithm having a time complexity of 
$O\left(|V_{f_1}|^2 \cdot |V_{f_2}|^2\right)$. Therefore, Bryant~\cite{BRYANT86}
already proposed to extend the \textit{Apply} operation to support ternary
operations and then use the equivalent \textit{if-then-else} (\textit{ITE})
representation:
\begin{center}
$
ITE\left(f_2, f_1|_{x_i=1}, f_1|_{x_i=0}\right) \equiv
f_2 \land f_1|_{x_i=1} \lor \overline{f_2} \land f_1|_{x_i=0}
$
\end{center}

\noindent
The time complexity then improves to be
$O\left(|V_{f_1}|^2 \cdot |V_{f_2}|\right)$~\cite{BRYANT86}.
~\cite[p. 686]{BRYANT86} lists Bryant's full pseudocode.

Bryant~\cite{BRYANT86} also described another, even more efficient way to compose
two function graphs. But this approach only applicable under restricted conditions.
\tbr

\paragraph*{Satisfy}
\mbox{} % workaround to get line break after paragraph

In essence, Bryant~\cite{BRYANT86} described two operations, i.e.
\textit{Satisfy-one} and \textit{Satisfy-all}, both concerned with the satisfying
set. As the name suggests, \textit{Satisfy-one} selects a single element and
\textit{Satisfy-all} selects all elements from the satisfying set.

\textit{Satisfy-one} traverses the OBDD depth-first and uses backtracking until
a terminal node of the constant function \textbf{1} is encountered. If such a
node is found, the corresponding Boolean function is satisfiable and true is
returned. Furthermore, an array representing the satisfying variable assignment
is assigned. The time complexity for a reduced graph is linear, i.e.
$O(|V_f|)$~\cite{BRYANT86}.

\textit{Satisfy-all} also traverses the OBDD depth-first. Every time the terminal
node having value \textbf{1} is traversed, it is printed. The recursive procedure
terminates as soon as the terminal node having value \textbf{0} is reached. This
results in a time complexity of $O(|V_f| \cdot |S_f|)$, whereas $S_f$ denotes the
satisfying set~\cite{BRYANT86}. \tbr

\section{Implementational Aspects}
\label{sec:implementational-aspects}

Bryant~\cite{BRYANT86} already observed the importance of utilizing efficient
techniques to implement the operations. Computation applied to OBDDs has a highly
dynamic character without specific memory access patterns~\cite{BRYANT92}.

Hence, the following sections cover important aspects to keep in mind when
implementing an OBDD framework efficiently, i.e. efficient data structures, how
to possibly approach the variable ordering problem and \textit{garbage collection}.
\tbr

\subsection{Efficient Data Structures}
\label{subsec:efficient-data-structures}

\tbd

\subsection{Dynamic Variable Ordering}
\label{subsec:dynamic-variable-ordering}

\begin{figure}[ht]
    \centering
    \includestandalone[height = 3cm]{figs/min-obdd}
    \label{fig:min-obdd}
    \caption{Minimized OBDD (optimal).}
\end{figure}
\tbd

\subsection{Garbage Collection}
\label{subsec:garbage-collection}

\tbd

\section{Limitations}
\label{sec:limitations}

\tbd

\section{Alternative Representations}
\label{sec:alternative-representations}

\tbd

% balance columns on last page
\balance

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
